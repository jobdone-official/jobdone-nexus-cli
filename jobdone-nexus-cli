#!/bin/bash

# Inspired by: https://github.com/openreplay/openreplay/blob/main/scripts/helmcharts/init.sh
# Inspired by: https://github.com/openreplay/openreplay/blob/main/scripts/helmcharts/openreplay-cli

# Check if the first argument is "install"
if [ "$1" != "install" ]; then
    echo "Usage: $0 install --hostname <hostname> --ssh-public-key <ssh_public_key> --zerotier-id <zerotier_id> --argocd-git-repo-url <argocd_git_repo_url> --argocd-git-token <argocd_git_token> --argocd-git-directory <argocd_git_directory> --argocd-project <argocd_project> --argocd-app-url <argocd_app_url> --trmm-mesh-agent <trmm_mesh_agent> --trmm-api-url <trmm_api_url> --trmm-client-id <trmm_client_id> --trmm-site-id <trmm_site_id> --trmm-auth-key <trmm_auth_key> --static-ip <static_ip> --gateway <gateway> --netmask <netmask> --dns <dns>"
    exit 1
fi
shift # Remove the 'install' argument, leaving only the named parameters

cat << "EOF"

       _       _     _____                     _   _                        _____ _      _____ 
      | |     | |   |  __ \                   | \ | |                      / ____| |    |_   _|
      | | ___ | |__ | |  | | ___  _ __   ___  |  \| | _____  ___   _ ___  | |    | |      | |  
  _   | |/ _ \| '_ \| |  | |/ _ \| '_ \ / _ \ | . ` |/ _ \ \/ / | | / __| | |    | |      | |  
 | |__| | (_) | |_) | |__| | (_) | | | |  __/ | |\  |  __/>  <| |_| \__ \ | |____| |____ _| |_ 
  \____/ \___/|_.__/|_____/ \___/|_| |_|\___| |_| \_|\___/_/\_\\__,_|___/  \_____|______|_____|


EOF

# Initialize variables
hostname=""
ssh_public_key=""
zerotier_id=""
argocd_git_repo_url=""
argocd_git_token=""
argocd_git_directory=""
argocd_project=""
argocd_app_url=""
trmm_mesh_agent=""
trmm_api_url=""
trmm_client_id=""
trmm_site_id=""
trmm_auth_key=""
static_ip=""
gateway=""
netmask=""
dns=""

# Parse named arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --hostname) hostname="$2"; shift ;;
        --ssh-public-key) ssh_public_key="$2"; shift ;;
        --zerotier-id) zerotier_id="$2"; shift ;;
        --argocd-git-repo-url) argocd_git_repo_url="$2"; shift ;;
        --argocd-git-token) argocd_git_token="$2"; shift ;;
        --argocd-git-directory) argocd_git_directory="$2"; shift ;;
        --argocd-project) argocd_project="$2"; shift ;;
        --argocd-app-url) argocd_app_url="$2"; shift ;;
        --trmm-mesh-agent) trmm_mesh_agent="$2"; shift ;;
        --trmm-api-url) trmm_api_url="$2"; shift ;;
        --trmm-client-id) trmm_client_id="$2"; shift ;;
        --trmm-site-id) trmm_site_id="$2"; shift ;;
        --trmm-auth-key) trmm_auth_key="$2"; shift ;;
        --static-ip) static_ip="$2"; shift ;;
        --gateway) gateway="$2"; shift ;;
        --netmask) netmask="$2"; shift ;;
        --dns) dns="$2"; shift ;;
        *) echo "Unknown parameter passed: $1"; exit 1 ;;
    esac
    shift
done

# Check if variables are set
if [ -z "$hostname" ] || [ -z "$ssh_public_key" ] || [ -z "$argocd_git_repo_url" ] || [ -z "$argocd_git_token" ] || [ -z "$argocd_git_directory" ] || [ -z "$argocd_project" ] || [ -z "$argocd_app_url" ] || [ -z "$zerotier_id" ] || [ -z "$trmm_mesh_agent" ] || [ -z "$trmm_api_url" ] || [ -z "$trmm_client_id" ] || [ -z "$trmm_site_id" ] || [ -z "$trmm_auth_key" ]; then
    echo "Usage: $0 install --hostname <hostname> --ssh-public-key <ssh_public_key> --zerotier-id <zerotier_id> --argocd-git-repo-url <argocd_git_repo_url> --argocd-git-token <argocd_git_token> --argocd-git-directory <argocd_git_directory> --argocd-project <argocd_project> --argocd-app-url <argocd_app_url> --trmm-mesh-agent <trmm_mesh_agent> --trmm-api-url <trmm_api_url> --trmm-client-id <trmm_client_id> --trmm-site-id <trmm_site_id> --trmm-auth-key <trmm_auth_key> --static-ip <static_ip> --gateway <gateway> --netmask <netmask> --dns <dns>"
    exit 1
fi

# Define log file with timestamp
log_file="jobdone_nexus_installation_$(date +%Y-%m-%dT%H:%M:%S).log"

# Function to log messages with levels
log() {
    local level=$1
    local message=$2
    local prefix=""
    case $level in
        INFO) prefix="\e[34mℹ️ [INFO]";;  # Blue
        WARN) prefix="\e[33m⚠️ [WARN]";;  # Yellow
        ERROR) prefix="\e[31m❌ [ERROR]";; # Red
        *) prefix="\e[0m📘";;             # Default
    esac
    echo -e "$prefix [$$(date +%Y-%m-%dT%H:%M:%S)] - $message\e[0m" | tee -a $log_file
}

# log params
log INFO "hostname: $hostname"
log INFO "ssh_public_key: $ssh_public_key"
log INFO "zerotier_id: $zerotier_id"
log INFO "argocd_git_repo_url: $argocd_git_repo_url"
log INFO "argocd_git_token: $argocd_git_token"
log INFO "argocd_git_directory: $argocd_git_directory"
log INFO "argocd_project: $argocd_project"
log INFO "argocd_app_url: $argocd_app_url"
log INFO "trmm_mesh_agent: $trmm_mesh_agent"
log INFO "trmm_api_url: $trmm_api_url"
log INFO "trmm_client_id: $trmm_client_id"
log INFO "trmm_site_id: $trmm_site_id"
log INFO "trmm_auth_key: $trmm_auth_key"
log INFO "static_ip: $static_ip"
log INFO "gateway: $gateway"
log INFO "netmask: $netmask"
log INFO "dns: $dns"

# check if this script is running with sudo
if [ -z "$SUDO_USER" ]; then
    log ERROR "Please run this script with sudo."
    exit 1
fi

# set timezone to UTC
log INFO "Setting timezone to UTC..."
sudo timedatectl set-timezone UTC || { log ERROR "Failed to set timezone to UTC."; exit 1; }
log INFO "Timezone set to UTC."

# set the hostname if it's provided
if [ -n "$hostname" ]; then
    log INFO "Setting hostname to $hostname..."
    sudo hostnamectl set-hostname "$hostname" || { log ERROR "Failed to set hostname."; exit 1; }
    # change /etc/hosts
    sudo sed -i "s/127\.0\.1\.1.*/127.0.1.1\t$hostname/" /etc/hosts || { log ERROR "Failed to update /etc/hosts."; exit 1; }
    log INFO "Hostname set to $hostname."
fi

# regenerate machine ID
log INFO "Regenerating machine ID..."
sudo rm -f /etc/machine-id
sudo systemd-machine-id-setup || { log ERROR "Failed to regenerate machine ID."; exit 1; }
log INFO "Machine ID regenerated successfully."

# install basic packages
log INFO "Installing basic packages..."
sudo apt update || { log ERROR "Failed to update apt."; exit 1; }
sudo apt upgrade -y || { log ERROR "Failed to upgrade packages."; exit 1; }
sudo apt install -y curl sudo unzip vim htop git net-tools wget ncdu network-manager || { log ERROR "Failed to install basic packages."; exit 1; }
log INFO "Basic packages installed successfully."

# add ssh public key
if [ -n "$ssh_public_key" ]; then
    log "Adding SSH public key to root's authorized_keys..."
    sudo mkdir -p /root/.ssh
    echo "$ssh_public_key" >> /root/.ssh/authorized_keys
    sudo chmod 600 /root/.ssh/authorized_keys
    sudo chown root:root /root/.ssh/authorized_keys
    log "SSH public key added successfully."
fi

check_k3s_ready() {
    while true; do
        if kubectl get nodes &> /dev/null; then
            log INFO "k3s is ready!"
            break
        else
            log INFO "Waiting for k3s to be ready..."
            sleep 5
        fi
    done
}

# k3s
if ! k3s --version &> /dev/null; then
    log INFO "Installing k3s without traefik..."
    curl -sfL https://get.k3s.io | sudo K3S_KUBECONFIG_MODE="644" INSTALL_K3S_EXEC="--disable traefik" sh - || { log ERROR "Failed to install k3s."; exit 1; }
    # Copy k3s.yaml to root's .kube directory and ensure directory exists
    sudo mkdir -p /root/.kube
    sudo cp /etc/rancher/k3s/k3s.yaml /root/.kube/config
    sudo chmod 0644 /root/.kube/config

    # If the script is run with sudo (indicating a non-root user invoked it)
    if [ ! -z "$SUDO_USER" ]; then
        # Determine non-root user's home directory dynamically
        non_root_user_home=$(getent passwd "$SUDO_USER" | cut -d: -f6)
        
        # Ensure the .kube directory exists in the non-root user's home and copy the config
        sudo mkdir -p "$non_root_user_home/.kube"
        sudo cp /etc/rancher/k3s/k3s.yaml "$non_root_user_home/.kube/config"
        sudo chmod 0644 "$non_root_user_home/.kube/config"
        sudo chown $SUDO_USER:$SUDO_USER "$non_root_user_home/.kube/config"
    fi

    sleep 10
    log INFO "k3s installed successfully."

    check_k3s_ready
else
    log WARN "k3s is already installed."
fi

# argocd autopilot
if ! argocd-autopilot version &> /dev/null; then
    log INFO "Installing ArgoCD Autopilot..."
    VERSION=$(curl --silent "https://api.github.com/repos/argoproj-labs/argocd-autopilot/releases/latest" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
    curl -L --output - "https://github.com/argoproj-labs/argocd-autopilot/releases/download/$VERSION/argocd-autopilot-linux-amd64.tar.gz" | tar zx
    mv ./argocd-autopilot-* /usr/local/bin/argocd-autopilot
    chmod +x /usr/local/bin/argocd-autopilot
    log INFO "ArgoCD Autopilot installed successfully."
else
    log WARN "ArgoCD Autopilot is already installed."
fi

# argocd application
## check if there is already a project with the same name
if ! kubectl get apps -n argocd | grep -q "\b$argocd_project\b"; then
    export GIT_TOKEN=$argocd_git_token

    # check if there is a trailing slash in the git repo url, if yes, remove it
    if [[ $argocd_git_repo_url == */ ]]; then
        argocd_git_repo_url=${argocd_git_repo_url%?}
    fi

    # check if there is a leading slash in the git directory, if yes, remove it
    if [[ $argocd_git_directory == /* ]]; then
        argocd_git_directory=${argocd_git_directory#?}
    fi

    export GIT_REPO="$argocd_git_repo_url/$argocd_git_directory"
    log INFO "GIT_REPO: $GIT_REPO"

    log INFO "GIT_TOKEN and GIT_REPO environment variables are set."

    log INFO "Bootstrapping the ArgoCD Autopilot repo..."
    argocd-autopilot repo bootstrap || { log ERROR "Failed to bootstrap the ArgoCD Autopilot repo."; exit 1; }
    log INFO "ArgoCD Autopilot repo bootstrapped successfully."

    log INFO "Creating project $argocd_project..."
    argocd-autopilot project create $argocd_project || { log ERROR "Failed to create project $argocd_project."; exit 1; }

    log INFO "Installing app..."
    argocd-autopilot app create demoapp --app $argocd_app_url -p $argocd_project || { log ERROR "Failed to install demo app."; exit 1; }
    log INFO "App installed successfully."

    log INFO "ArgoCD application installed successfully."
else
    log WARN "ArgoCD application already exists."
fi

# eget
if ! eget --version &> /dev/null; then
    log INFO "Installing eget..."
    download_url=$(curl https://api.github.com/repos/zyedidia/eget/releases/latest -s | grep linux_amd64 | grep browser_download_url | cut -d '"' -f4)
    curl -SsL ${download_url} -o /tmp/eget.tar.gz || { log ERROR "Failed to download eget."; exit 1; }
    tar -xf /tmp/eget.tar.gz --strip-components=1 -C /tmp/ || { log ERROR "Failed to extract eget."; exit 1; }
    sudo mv /tmp/eget /usr/local/bin/eget || { log ERROR "Failed to move eget to /usr/local/bin."; exit 1; }
    sudo chmod +x /usr/local/bin/eget || { log ERROR "Failed to make eget executable."; exit 1; }
    log INFO "eget installed successfully."
else
    log WARN "eget is already installed."
fi

# k9s
if ! k9s version &> /dev/null; then
    log INFO "Installing k9s to /usr/local/bin"
    sudo /usr/local/bin/eget -q --to /usr/local/bin derailed/k9s --asset=tar.gz --asset=^sbom || { log ERROR "Failed to install k9s."; exit 1; }
    log INFO "k9s installed successfully."
else
    log WARN "k9s is already installed."
fi

# zerotier
if ! zerotier-cli -v &> /dev/null; then
    log INFO "Setting up ZeroTier..."
    curl -s https://install.zerotier.com | sudo bash || { log ERROR "Failed to install ZeroTier."; exit 1; }
    sudo zerotier-cli join $zerotier_id || { log ERROR "Failed to join ZeroTier network."; exit 1; }
    log INFO "ZeroTier setup complete."
else
    log WARN "ZeroTier is already installed."
fi

# tacticalrmm agent
if [ ! -f /usr/local/bin/rmmagent ]; then
    log INFO "Installing TacticalRMM agent..."
    wget https://raw.githubusercontent.com/netvolt/LinuxRMM-Script/main/rmmagent-linux.sh || { log ERROR "Failed to download TacticalRMM script."; exit 1; }
    sudo chmod +x rmmagent-linux.sh
    sudo ./rmmagent-linux.sh install 'amd64' $trmm_mesh_agent $trmm_api_url $trmm_client_id $trmm_site_id $trmm_auth_key server || { log ERROR "Failed to install TacticalRMM agent."; exit 1; }
    log INFO "TacticalRMM agent installed successfully, check if the token was accepted."
else
    log WARN "TacticalRMM agent is already installed."
fi

log INFO "JobDone Nexus Installation complete!"

# if network configuration is provided, apply it
if [ -n "$static_ip" ] && [ -n "$gateway" ] && [ -n "$netmask" ] && [ -n "$dns" ]; then
    log INFO "Setting up network configuration..."
    
    # List all available network interfaces and prompt user to select one
    log INFO "Identifying available network interfaces..."
    nmcli device status
    read -p "Enter the interface name to configure: " INTERFACE_NAME

    CONNECTION_NAME=$(nmcli -t -f UUID,TYPE,DEVICE con show --active | grep "$INTERFACE_NAME" | cut -d':' -f1)

    if [ -z "$CONNECTION_NAME" ]; then
        log INFO "Selected interface is not active or does not exist."
        exit 1
    fi

    TIMESTAMP=$(date +%Y-%m-%dT%H:%M:%S)
    BACKUP_CONFIG="/tmp/network_config_backup_${CONNECTION_NAME}_${TIMESTAMP}.nmconnection"
    nmcli con export "$CONNECTION_NAME" > "$BACKUP_CONFIG"
    log INFO "Current configuration for $INTERFACE_NAME backed up to $BACKUP_CONFIG"

    # Set static IP
    nmcli con mod "$CONNECTION_NAME" ipv4.addresses "$static_ip/$netmask" ipv4.gateway "$gateway" ipv4.dns "$dns" ipv4.method manual

    # Restart network connection to apply changes
    nmcli con down "$CONNECTION_NAME" && nmcli con up "$CONNECTION_NAME"

    # Check for internet connectivity
    ping -c 4 8.8.8.8 > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        log INFO "Internet connection is up. Static IP set successfully."
        NEW_CONFIG="/tmp/network_config_new_${CONNECTION_NAME}_${TIMESTAMP}.nmconnection"
        nmcli con export "$CONNECTION_NAME" > "$NEW_CONFIG"
        log INFO "New configuration applied. Review changes below:"
        diff "$BACKUP_CONFIG" "$NEW_CONFIG" || log "No changes were detected."
    else
        log WARN "Internet connection failed."
        read -p "Restore original configuration? (yes/no): " RESTORE_CHOICE
        if [[ "$RESTORE_CHOICE" == "yes" ]]; then
            nmcli con load "$BACKUP_CONFIG" && nmcli con up "$CONNECTION_NAME"
            log WARN "Original configuration restored."
        else
            log WARN "Keeping new configuration as per user request."
        fi
    fi
fi

# ask for reboot
read -p "Reboot now? (yes/no): " REBOOT_CHOICE
if [[ "$REBOOT_CHOICE" == "yes" ]]; then
    log INFO "Rebooting..."
    reboot
else
    log INFO "Reboot skipped."
fi
