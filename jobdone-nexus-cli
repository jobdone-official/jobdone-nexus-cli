#!/bin/bash

# Inspired by: https://github.com/openreplay/openreplay/blob/main/scripts/helmcharts/init.sh
# Inspired by: https://github.com/openreplay/openreplay/blob/main/scripts/helmcharts/openreplay-cli

# Check if the first argument is "install"
if [ "$1" != "install" ]; then
    echo "Usage: $0 install --hostname <hostname> --ssh-private-key-name <ssh_private_key_name> --ssh-private-key <ssh_private_key> --zerotier-id <zerotier_id> --argocd-git-repo-url <argocd_git_repo_url> --argocd-app-path <argocd_app_path> --hcp-client-id <hcp_client_id> --hcp-client-id-secret <hcp_client_id_secret> --hcp-org-id <hcp_org_id> --hcp-project-id <hcp_project_id> --trmm-mesh-agent <trmm_mesh_agent> --trmm-api-url <trmm_api_url> --trmm-client-id <trmm_client_id> --trmm-site-id <trmm_site_id> --trmm-auth-key <trmm_auth_key> --static-ip <static_ip> --gateway <gateway> --netmask <netmask> --dns <dns>"
    exit 1
fi
shift # Remove the 'install' argument, leaving only the named parameters

cat << "EOF"

       _       _     _____                     _   _                        _____ _      _____ 
      | |     | |   |  __ \                   | \ | |                      / ____| |    |_   _|
      | | ___ | |__ | |  | | ___  _ __   ___  |  \| | _____  ___   _ ___  | |    | |      | |  
  _   | |/ _ \| '_ \| |  | |/ _ \| '_ \ / _ \ | . ` |/ _ \ \/ / | | / __| | |    | |      | |  
 | |__| | (_) | |_) | |__| | (_) | | | |  __/ | |\  |  __/>  <| |_| \__ \ | |____| |____ _| |_ 
  \____/ \___/|_.__/|_____/ \___/|_| |_|\___| |_| \_|\___/_/\_\\__,_|___/  \_____|______|_____|


EOF

# Initialize variables
hostname=""
ssh_private_key_name=""
ssh_private_key=""
zerotier_id=""
argocd_git_repo_url=""
argocd_app_path=""
hcp_client_id=""
hcp_client_id_secret=""
hcp_org_id=""
hcp_project_id=""
trmm_mesh_agent=""
trmm_api_url=""
trmm_client_id=""
trmm_site_id=""
trmm_auth_key=""
static_ip=""
gateway=""
netmask=""
dns=""

# Parse named arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --hostname) hostname="$2"; shift ;;
        --ssh-private-key-name) ssh_private_key_name="$2"; shift ;;
        --ssh-private-key) ssh_private_key="$2"; shift ;;
        --zerotier-id) zerotier_id="$2"; shift ;;
        --argocd-git-repo-url) argocd_git_repo_url="$2"; shift ;;
        --argocd-app-path) argocd_app_path="$2"; shift ;;
        --hcp-client-id) hcp_client_id="$2"; shift ;;
        --hcp-client-id-secret) hcp_client_id_secret="$2"; shift ;;
        --hcp-org-id) hcp_org_id="$2"; shift ;;
        --hcp-project-id) hcp_project_id="$2"; shift ;;
        --trmm-mesh-agent) trmm_mesh_agent="$2"; shift ;;
        --trmm-api-url) trmm_api_url="$2"; shift ;;
        --trmm-client-id) trmm_client_id="$2"; shift ;;
        --trmm-site-id) trmm_site_id="$2"; shift ;;
        --trmm-auth-key) trmm_auth_key="$2"; shift ;;
        --static-ip) static_ip="$2"; shift ;;
        --gateway) gateway="$2"; shift ;;
        --netmask) netmask="$2"; shift ;;
        --dns) dns="$2"; shift ;;
        *) echo "Unknown parameter passed: $1"; exit 1 ;;
    esac
    shift
done

# Check if variables are set
if [ -z "$hostname" ] || [ -z "$ssh_private_key_name" ] || [ -z "$ssh_private_key" ] || [ -z "$argocd_git_repo_url" ] || [ -z "$argocd_app_path" ] || [ -z "$hcp_client_id" ] || [ -z "$hcp_client_id_secret" ] || [ -z "$hcp_org_id" ] || [ -z "$hcp_project_id" ] || [ -z "$trmm_mesh_agent" ] || [ -z "$trmm_api_url" ] || [ -z "$trmm_client_id" ] || [ -z "$trmm_site_id" ] || [ -z "$trmm_auth_key" ]; then
    echo "Usage: $0 install --hostname <hostname> --ssh-private-key-name <ssh_private_key_name> --ssh-private-key <ssh_private_key> --zerotier-id <zerotier_id> --argocd-git-repo-url <argocd_git_repo_url> --argocd-app-path <argocd_app_path> --hcp-client-id <hcp_client_id> --hcp-client-id-secret <hcp_client_id_secret> --hcp-org-id <hcp_org_id> --hcp-project-id <hcp_project_id> --trmm-mesh-agent <trmm_mesh_agent> --trmm-api-url <trmm_api_url> --trmm-client-id <trmm_client_id> --trmm-site-id <trmm_site_id> --trmm-auth-key <trmm_auth_key> --static-ip <static_ip> --gateway <gateway> --netmask <netmask> --dns <dns>"
    exit 1
fi

# Define log file with timestamp
log_file="jobdone_nexus_installation_$(date +%Y-%m-%dT%H:%M:%S).log"

# Function to log messages with levels
log() {
    local level=$1
    local message=$2
    local prefix=""
    case $level in
        INFO) prefix="\e[34mℹ️ [INFO]";;  # Blue
        WARN) prefix="\e[33m⚠️ [WARN]";;  # Yellow
        ERROR) prefix="\e[31m❌ [ERROR]";; # Red
        *) prefix="\e[0m📘";;             # Default
    esac
    echo -e "$prefix [$(date +%Y-%m-%dT%H:%M:%S)] - $message\e[0m" | tee -a $log_file
}

# log params
echo "hostname: $hostname"
echo "zerotier_id: $zerotier_id"
echo "ssh_private_key_name: $ssh_private_key_name"
echo "argocd_git_repo_url: $argocd_git_repo_url"
echo "argocd_app_path: $argocd_app_path"
echo "hcp_client_id: $hcp_client_id"
echo "hcp_org_id: $hcp_org_id"
echo "hcp_project_id: $hcp_project_id"
echo "trmm_mesh_agent: $trmm_mesh_agent"
echo "trmm_api_url: $trmm_api_url"
echo "trmm_client_id: $trmm_client_id"
echo "trmm_site_id: $trmm_site_id"
echo "trmm_auth_key: $trmm_auth_key"
echo "static_ip: $static_ip"
echo "gateway: $gateway"
echo "netmask: $netmask"
echo "dns: $dns"

# check if this script is running with sudo
if [ -z "$SUDO_USER" ]; then
    log ERROR "Please run this script with sudo."
    exit 1
fi

# set timezone to UTC
log INFO "Setting timezone to UTC..."
sudo timedatectl set-timezone UTC || { log ERROR "Failed to set timezone to UTC."; exit 1; }
log INFO "Timezone set to UTC."

# set the hostname if it's provided
if [ -n "$hostname" ]; then
    log INFO "Setting hostname to $hostname..."
    sudo hostnamectl set-hostname "$hostname" || { log ERROR "Failed to set hostname."; exit 1; }
    # change /etc/hosts
    sudo sed -i "s/127\.0\.1\.1.*/127.0.1.1\t$hostname/" /etc/hosts || { log ERROR "Failed to update /etc/hosts."; exit 1; }
    log INFO "Hostname set to $hostname."
fi

# regenerate machine ID
log INFO "Regenerating machine ID..."
sudo rm -f /etc/machine-id
sudo systemd-machine-id-setup || { log ERROR "Failed to regenerate machine ID."; exit 1; }
log INFO "Machine ID regenerated successfully."

# install basic packages
log INFO "Installing basic packages..."
sudo apt update || { log ERROR "Failed to update apt."; exit 1; }
sudo apt upgrade -y || { log ERROR "Failed to upgrade packages."; exit 1; }
sudo apt install -y curl sudo unzip vim htop git net-tools wget ncdu network-manager || { log ERROR "Failed to install basic packages."; exit 1; }
log INFO "Basic packages installed successfully."

# Add SSH private key if both name and key are provided
if [ -n "$ssh_private_key_name" ] && [ -n "$ssh_private_key" ]; then
    log "Adding SSH private key"

    # Determine the current user's home directory
    USER_HOME=$(eval echo ~$USER)

    # Ensure the .ssh directory exists
    mkdir -p "$USER_HOME/.ssh"

    # Write the private key to the specified file
    echo "$ssh_private_key" > "$USER_HOME/.ssh/$ssh_private_key_name"

    # Set the file's permissions to be read/write by the file owner only
    chmod 600 "$USER_HOME/.ssh/$ssh_private_key_name"

    # Inform about the successful addition
    log "SSH private key added successfully."
fi

check_k3s_ready() {
    while true; do
        if kubectl get nodes &> /dev/null; then
            log INFO "k3s is ready!"
            break
        else
            log INFO "Waiting for k3s to be ready..."
            sleep 5
        fi
    done
}

# zerotier (optional)
if [ -n "$zerotier_id" ]; then
    log INFO "Setting up ZeroTier..."
    if ! zerotier-cli -v &> /dev/null; then
        curl -s https://install.zerotier.com | sudo bash || { log ERROR "Failed to install ZeroTier."; exit 1; }
        sudo zerotier-cli join $zerotier_id || { log ERROR "Failed to join ZeroTier network."; exit 1; }
        log INFO "ZeroTier setup complete."
    else
        log WARN "ZeroTier is already installed."
    fi
else
    log WARN "ZeroTier ID is not provided. Skipping ZeroTier setup."
fi

# k3s
if ! k3s --version &> /dev/null; then
    log INFO "Installing k3s without traefik..."
    curl -sfL https://get.k3s.io | sudo K3S_KUBECONFIG_MODE="644" INSTALL_K3S_EXEC="--disable traefik" sh - || { log ERROR "Failed to install k3s."; exit 1; }
    # Copy k3s.yaml to root's .kube directory and ensure directory exists
    sudo mkdir -p /root/.kube
    sudo cp /etc/rancher/k3s/k3s.yaml /root/.kube/config
    sudo chmod 0644 /root/.kube/config

    # If the script is run with sudo (indicating a non-root user invoked it)
    if [ ! -z "$SUDO_USER" ]; then
        # Determine non-root user's home directory dynamically
        non_root_user_home=$(getent passwd "$SUDO_USER" | cut -d: -f6)
        
        # Ensure the .kube directory exists in the non-root user's home and copy the config
        sudo mkdir -p "$non_root_user_home/.kube"
        sudo cp /etc/rancher/k3s/k3s.yaml "$non_root_user_home/.kube/config"
        sudo chmod 0644 "$non_root_user_home/.kube/config"
        sudo chown $SUDO_USER:$SUDO_USER "$non_root_user_home/.kube/config"
    fi

    sleep 10
    log INFO "k3s installed successfully."

    check_k3s_ready
else
    log WARN "k3s is already installed."
fi

# create jobdone-nexus namespace
if ! kubectl get namespace jobdone-nexus &> /dev/null; then
    log INFO "Creating jobdone-nexus namespace..."
    kubectl create namespace jobdone-nexus || { log ERROR "Failed to create jobdone-nexus namespace."; exit 1;}
    log INFO "jobdone-nexus namespace created successfully."
else
    log WARN "jobdone-nexus namespace already exists."
fi

# install argocd
if ! kubectl get namespace argocd &> /dev/null; then
    log INFO "Installing ArgoCD..."
    kubectl create namespace argocd || log ERROR "Failed to create argocd namespace.";
    kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml || log ERROR "Failed to install ArgoCD.";
    log INFO "ArgoCD installed successfully."
else
    log WARN "ArgoCD is already installed."
fi

# install argocd cli
if kubectl ! argocd version &> /dev/null; then
    log INFO "Installing ArgoCD CLI..."
    curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
    sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
    rm argocd-linux-amd64
    log INFO "ArgoCD CLI installed successfully."
else
    log WARN "ArgoCD CLI is already installed."
fi

# if the argocd namespace exists and argocd cli are installed, then connect to the argocd_git_repo_url and install the argocd_app
if kubectl get namespace argocd &> /dev/null && argocd version &> /dev/null; then
    log INFO "Installing the ArgoCD app..."
    # set the current context to argocd namespace
    kubectl config set-context --current --namespace=argocd
    # add the argocd_git_repo_url to the argocd cli
    argocd repo add $argocd_git_repo_url --ssh-private-key-path /root/.ssh/$ssh_private_key_name || log ERROR "Failed to add ArgoCD repo.";
    argocd app create $argocd_app_path --repo $argocd_git_repo_url --path $argocd_app_path --dest-server https://kubernetes.default.svc --dest-namespace argocd --sync-policy automated --auto-prune || log ERROR "Failed to create ArgoCD app.";
    log INFO "ArgoCD app installed successfully."
else
    log WARN "ArgoCD namespace does not exist or ArgoCD CLI is not installed. Skipping ArgoCD app installation."
fi

# eget
if ! eget --version &> /dev/null; then
    log INFO "Installing eget..."
    download_url=$(curl https://api.github.com/repos/zyedidia/eget/releases/latest -s | grep linux_amd64 | grep browser_download_url | cut -d '"' -f4)
    curl -SsL ${download_url} -o /tmp/eget.tar.gz || { log ERROR "Failed to download eget."; exit 1; }
    tar -xf /tmp/eget.tar.gz --strip-components=1 -C /tmp/ || { log ERROR "Failed to extract eget."; exit 1; }
    sudo mv /tmp/eget /usr/local/bin/eget || { log ERROR "Failed to move eget to /usr/local/bin."; exit 1; }
    sudo chmod +x /usr/local/bin/eget || { log ERROR "Failed to make eget executable."; exit 1; }
    log INFO "eget installed successfully."
else
    log WARN "eget is already installed."
fi

# helm
if ! helm version &> /dev/null; then
    log INFO "Installing helm..."
    curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash || log ERROR "Failed to install helm.";
    chmod 700 get_helm.sh
    ./get_helm.sh
    log INFO "helm installed successfully."
else
    log WARN "helm is already installed."
fi

# k9s
if ! k9s version &> /dev/null; then
    log INFO "Installing k9s to /usr/local/bin"
    sudo /usr/local/bin/eget -q --to /usr/local/bin derailed/k9s --asset=tar.gz --asset=^sbom || { log ERROR "Failed to install k9s."; exit 1; }
    log INFO "k9s installed successfully."
else
    log WARN "k9s is already installed."
fi

# HCP Secrets
# https://developer.hashicorp.com/vault/tutorials/hcp-vault-secrets-get-started/kubernetes-vso
if helm version &> /dev/null && kubectl version &> /dev/null; then
    if [ -n "$hcp_client_id" && -n "$hcp_client_id_secret" ]; then
        log INFO "Installing HCP Secrets..."
        # add the hashicorp helm repository
        helm repo add hashicorp https://helm.releases.hashicorp.com || log ERROR "Failed to add hashicorp helm repository."
        # create a namespace for the vault-secrets-operator
        helm install vault-secrets-operator hashicorp/vault-secrets-operator \
        --namespace vault-secrets-operator-system \
        --create-namespace

        # create a secret for the HCP principal client id and secret
        kubectl create secret generic vso-sp \
          --namespace jobdone-nexus \
          --from-literal=clientID=$hcp_client_id \
          --from-literal=clientSecret=$hcp_client_id_secret

        # create vault secret operator with hcp organization and project id
        kubectl create -f - <<EOF
---
apiVersion: secrets.hashicorp.com/v1beta1
kind: HCPAuth
metadata:
    name: jobdone-nexus
    namespace: vault-secrets-operator-system
spec:
    organizationID: $hcp_org_id
    projectID: $hcp_project_id
    servicePrincipal:
        secretRef: vso-sp
EOF

        log INFO "HCP Secrets installed successfully."
    else
        log WARN "HCP principal client id is not provided. Skipping HCP Secrets installation."
    fi
else
    log WARN "Helm or kubectl is not installed. Skipping HCP Secrets installation."
fi

# tacticalrmm agent
if [ ! -f /usr/local/bin/rmmagent ]; then
    log INFO "Installing TacticalRMM agent..."
    wget https://raw.githubusercontent.com/netvolt/LinuxRMM-Script/main/rmmagent-linux.sh || { log ERROR "Failed to download TacticalRMM script."; exit 1; }
    sudo chmod +x rmmagent-linux.sh
    sudo ./rmmagent-linux.sh install 'amd64' $trmm_mesh_agent $trmm_api_url $trmm_client_id $trmm_site_id $trmm_auth_key server || { log ERROR "Failed to install TacticalRMM agent."; exit 1; }
    log INFO "TacticalRMM agent installed successfully, check if the token was accepted."
else
    log WARN "TacticalRMM agent is already installed."
fi

log INFO "JobDone Nexus Installation complete!"

# if network configuration is provided, apply it
if [ -n "$static_ip" ] && [ -n "$gateway" ] && [ -n "$netmask" ] && [ -n "$dns" ]; then
    log INFO "Setting up network configuration..."
    
    # List all available network interfaces and prompt user to select one
    log INFO "Identifying available network interfaces..."
    nmcli device status
    read -p "Enter the interface name to configure: " INTERFACE_NAME

    CONNECTION_NAME=$(nmcli -t -f UUID,TYPE,DEVICE con show --active | grep "$INTERFACE_NAME" | cut -d':' -f1)

    if [ -z "$CONNECTION_NAME" ]; then
        log INFO "Selected interface is not active or does not exist."
        exit 1
    fi

    TIMESTAMP=$(date +%Y-%m-%dT%H:%M:%S)
    BACKUP_CONFIG="/tmp/network_config_backup_${CONNECTION_NAME}_${TIMESTAMP}.nmconnection"
    nmcli con export "$CONNECTION_NAME" > "$BACKUP_CONFIG"
    log INFO "Current configuration for $INTERFACE_NAME backed up to $BACKUP_CONFIG"

    # Set static IP
    nmcli con mod "$CONNECTION_NAME" ipv4.addresses "$static_ip/$netmask" ipv4.gateway "$gateway" ipv4.dns "$dns" ipv4.method manual

    # Restart network connection to apply changes
    nmcli con down "$CONNECTION_NAME" && nmcli con up "$CONNECTION_NAME"

    # Check for internet connectivity
    ping -c 4 8.8.8.8 > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        log INFO "Internet connection is up. Static IP set successfully."
        NEW_CONFIG="/tmp/network_config_new_${CONNECTION_NAME}_${TIMESTAMP}.nmconnection"
        nmcli con export "$CONNECTION_NAME" > "$NEW_CONFIG"
        log INFO "New configuration applied. Review changes below:"
        diff "$BACKUP_CONFIG" "$NEW_CONFIG" || log "No changes were detected."
    else
        log WARN "Internet connection failed."
        read -p "Restore original configuration? (yes/no): " RESTORE_CHOICE
        if [[ "$RESTORE_CHOICE" == "yes" ]]; then
            nmcli con load "$BACKUP_CONFIG" && nmcli con up "$CONNECTION_NAME"
            log WARN "Original configuration restored."
        else
            log WARN "Keeping new configuration as per user request."
        fi
    fi
fi

# ask for reboot
read -p "Reboot now? (yes/no): " REBOOT_CHOICE
if [[ "$REBOOT_CHOICE" == "yes" ]]; then
    log INFO "Rebooting..."
    reboot
else
    log INFO "Reboot skipped."
fi
